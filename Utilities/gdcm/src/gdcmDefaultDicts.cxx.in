/*=========================================================================
                                                                                
  Program:   gdcm
  Module:    gdcmDefaultDicts.cxx.in
  Language:  C++
  Date:      $Date$
  Version:   $Revision$
                                                                                
  Copyright (c) CREATIS (Centre de Recherche et d'Applications en Traitement de
  l'Image). All rights reserved. See Doc/License.txt or
  http://www.creatis.insa-lyon.fr/Public/Gdcm/License.html for details.
                                                                                
     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notices for more information.
                                                                                
=========================================================================*/

#ifndef GDCMDEFAULTDICTS_H
#define GDCMDEFAULTDICTS_H

#include "gdcmDict.h"
#include "gdcmDictEntry.h"
#include "gdcmTS.h"
#include "gdcmVR.h"
#include "gdcmDicomDirElement.h"

namespace gdcm
{

typedef struct
{
  uint16_t group;
  uint16_t element;
  const char *vr;
  const char *fourth;
  const char *name;
} DICT_ENTRY;

static DICT_ENTRY datadir[] = {
@DICOM_DATA_DICTIONARY@
};

void FillDefaultDataDict(Dict *d)
{
  unsigned int i = 0;
  DICT_ENTRY n = datadir[i];
  while( n.name != 0 )
    {
    const DictEntry e( n.group, n.element, n.vr, n.fourth, n.name);
    d->AddNewEntry( e );
    n = datadir[++i];
    }
}

void FillDefaultTSDict(TSHT & ts)
{
@DICOM_TS_DICTIONARY@
}

void FillDefaultVRDict(VRHT & vr)
{
@DICOM_VR_DICTIONARY@
}

typedef struct
{
  const char *type;
  unsigned short group;
  unsigned short element;
  const char *value;
} ELEMENT;

static ELEMENT dataelement[] = {
@DICOM_DIR_DICTIONARY@
};

void FillDefaultDIRDict(DicomDirElement *dde)
{
  unsigned int i = 0;
  ELEMENT e = dataelement[i];
  Element elem;
  while( e.type != 0 )
    {
    elem.Group = e.group;
    elem.Elem  = e.element;
    elem.Value = e.value;
    dde->AddNewEntry( e.type, elem);
    e = dataelement[++i];
    }
}

} //end gdcm namespace
#endif

