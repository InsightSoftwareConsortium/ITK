%begin %{
#include "PatchedPython27pyconfig.h"
%}

%extend itkPyBuffer@PyBufferTypes@{
    %pythoncode %{

    def GetArrayViewFromImage(image, keepAxes=False):
        """Get a NumPy array view of a ITK Image.

        When *keepAxes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keepAxes == False:
            shape = shape[::-1]

        pixelType     = "@PixelType@"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBuffer@PyBufferTypes@._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image):
        """Get a NumPy ndarray from an ITK Image.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBuffer@PyBufferTypes@.GetArrayViewFromImage(image)

        # perform deep copy of the image buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, isVector=False):
        """Get an ITK Image view of a NumPy array.

        If isVector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."

        if ( ndarr.ndim == 3 and isVector ) or (ndarr.ndim == 4):
            imgview = itkPyBuffer@PyBufferTypes@._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBuffer@PyBufferTypes@._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, isVector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If isVector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

        # perform deep copy of the array buffer
        array_copy = numpy.array(ndarr)

        image = itkPyBuffer@PyBufferTypes@.GetImageViewFromArray(array_copy, isVector)

        # attaches the copy of the array to the image to avoid releasing memory
        # when leaving current scope.
        image._ndarr = array_copy
        return image

    GetImageFromArray = staticmethod(GetImageFromArray)

  %}
};
